with Ada.Text_IO;
with Ada.Unchecked_Deallocation;
package body Maps_G is

   procedure Get (M       : Map;
                  Key     : in  Key_Type;
                  Value   : out Value_Type;
                  Success : out Boolean) is
      Aux : Map;
      i:Natural;
   begin
      Aux(1..Max) := M(1..Max);
      i := 1;
      Success := False;
      while not Success and Max> i loop
         if Aux(i).Key = Key then
            Value := Aux(i).Value;
            Success := True;
         end if;
         i := i + 1;
      end loop;
   end Get;


   procedure Put (M     : in out Map;
                  Key   : Key_Type;
                  Value : Value_Type) is
      Aux : Map;
      Found : Boolean;
      Added : Boolean;
	i:Natural;
   begin
      -- Si ya existe Key, cambiamos su Value
	Aux(1..Max) := M(1..Max);
      i := 1;
      Added := False;
      Found := False;
      while not Found and Max>i loop
         if Aux(i).Key = Key then
            Aux(i).Value := Value;
            Found := True;
         end if;
         i :=  i + 1;
      end loop;
      -- Si no hemos encontrado Key aÃ±adimos
      i := 1 ;
      if not Found then
	 while not Added and Max>i loop
	 	if not Aux(i).Contenido then
       		  M(i).Key := Key;
		  M(i).Value := Value;
		  M(i).Contenido := True;  
		  Added:=True;
		  i := i+1; 
	 	  if i>Max then
	 		raise Full_Map;
		  end if;
 		else 
		 i := i+1;
		end if;
	end loop;
	end if;
   end Put;



   procedure Delete (M      : in out Map;
                     Key     : in  Key_Type;
                     Success : out Boolean) is
     Aux : Map;
	i:Natural;
    begin
      Aux(1..Max) := M(1..Max);
      i := 1;
      Success := False;
      while not Success and Max>i loop
		if Aux(i).Key = Key then
		  Success := True;
		  M(i).Contenido := False;  
		 else
		   i := i+1;
		 end if;
      end loop;
   end Delete;

   function Map_Length (M : Map) return Natural is
   i:Natural := 1 ;
   Elementos: Natural:=0;
   begin
 	while i /= Max loop
		if M(i).Contenido = True then
			Elementos:=Elementos+1;
		end if;
		i := i + 1;
	end loop;
      return Elementos;
   end Map_Length;

 --Falta
   function First (M: Map) return Cursor is
   Aux : Map;
   i:Natural :=1;
    begin
      Aux(1..Max) := M(1..Max);
	while not Aux(i).Contenido loop
		i := i +1;
	end loop;
      return (M => Aux(i), Element_A => i);
   end First;

   function Last (M:Map) return Cursor is
    Aux : Map;
   i:Natural :=Max;
    begin
      Aux(1..Max) := M(1..Max);
	while not Aux(i).Contenido loop
		i := i - 1;
	end loop;
      return (M => Aux(i), Element_A => i);
   end Last;
--REvisar
  procedure Prev(C: in out Cursor) is
  begin
	while C.Element_A /= 0 loop
		C.Element_A:= C.Element_A - 1;
  	 end loop;
  end Prev;
--Revisar
   procedure Next (C: in out Cursor) is
   begin
	while C.Element_A>Max loop
		C.Element_A:= C.Element_A + 1;
  	 end loop;
   end Next;

   function Element (C: Cursor) return Element_Type is
   begin
      if C.Element_A.Contenido = True then
         return (Key   => C.Element_A.Key,
                 Value => C.Element_A.Value);
      else
         raise No_Element;
      end if;
   end Element;

   function Has_Element (C: Cursor) return Boolean is
   begin
      if C.Element_A.Contenido = True then
         return True;
      else
         return False;
      end if;
   end Has_Element;

end Maps_G;

